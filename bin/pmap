#!/usr/bin/env python

# Provisioning Map Helper

import argparse
import json
import sys
import uuid
import re


VALID_ROLES = ["boot", "system"]


def pmap_version(data):
    value = get_key(data, "attributes.PMAPversion")
    if value is None:
        # Try parsing as fully assembled image.json
        value = get_key(data, "layout.provisionmap.attributes.PMAPversion")
        if value is None:
            sys.stderr.write("Error: No version\n")
            sys.exit(1)

    if isinstance(value, str):
        pass
    else:
        sys.stderr.write("Error: Version is not a string\n")
        sys.exit(1)

    parts = value.split('.')
    parts.extend(['0'] * (3 - len(parts)))

    try:
        # Return a tuple of the version components as integers
        major = int(parts[0])
        minor = int(parts[1])
        patch = int(parts[2])
        return major, minor, patch
    except ValueError:
        sys.stderr.write(f"Error: Invalid version format in '{value}'\n")
        sys.exit(1)


# Top level PMAP validator
def validate(data):
    major, minor, patch = pmap_version(data)
    # TODO
    return major, minor, patch


# Validates a static object and returns mandatory keys
def chk_static(data):
    role = data.get("role")

    # role: (mandatory, string)
    if not role:
        sys.stderr.write("Error: role is mandatory in a static object.\n")
        sys.exit(1)

    if role not in VALID_ROLES:
        sys.stderr.write(f"Error: Invalid 'role': '{role}'. Must be one of {VALID_ROLES}.\n")
        sys.exit(1)

    # id: (optional, string)
    if "id" in data:
        id_val = data.get("id")
        if not isinstance(id_val, str):
            sys.stderr.write("Error: id is not a string.\n")
            sys.exit(1)

    # uuid: (optional, valid UUID string); allow placeholders like <FOO>
    if "uuid" in data:
        uuid_val = data.get("uuid")
        if not isinstance(uuid_val, str):
            sys.stderr.write("Error: uuid is not a string.\n")
            sys.exit(1)
        # Skip strict validation for obvious placeholders
        if "<" in uuid_val or ">" in uuid_val:
            pass
        else:
            try:
                uuid.UUID(uuid_val)
            except ValueError:
                if (re.match(r'^[0-9a-f]{8}$', uuid_val, re.IGNORECASE) or
                    re.match(r'^[0-9a-f]{4}-[0-9a-f]{4}$', uuid_val, re.IGNORECASE)):
                    pass  # Accept as valid VFAT UUID (label)
                else:
                    sys.stderr.write(f"Error: uuid is invalid: '{uuid_val}'.\n")
                    sys.exit(1)

    # Return mandatory
    return role


"""
Generate slot.map compatible triplets from a slotted PMAP JSON.
See layer/rpi/device/ab-slots.adoc

Rules
- Physical partitions are encountered in JSON order; keep a global incrementing
  partition counter for all physical partitions (including non-slot ones under
  top-level "partitions").
- Partitions inside an encrypted LUKS2 device use a mapper triplet of the form
  mapper:<mname>:<part>, where <part> starts at 1 inside each mapper name and
  increments per encountered partition in JSON order.
"""
def slotvars(data):
    # Check for slotted system_type
    if not any(e.get("attributes", {}).get("system_type") == "slotted" for e in data):
        sys.stderr.write("Error: Not slotted\n")
        sys.exit(1)

    # Track physical partition numbering (1-based) across the image in JSON order
    physical_part_index = 0

    # Track per-mapper partition numbering (1-based) for encrypted containers
    mapper_part_index = {}

    # Accumulate triplets for each slot+role
    # Keys are tuples like ("A", "boot") or ("B", "system")
    triplets = {}

    def next_mapper_index(name):
        mapper_part_index[name] = mapper_part_index.get(name, 0) + 1
        return mapper_part_index[name]

    # First pass: walk entries in order and assign indices/triplets
    for entry in data:
        # Top-level physical partitions (non-slot items like config/data)
        if "partitions" in entry and isinstance(entry.get("partitions"), list):
            physical_part_index += len(entry["partitions"])
            continue

        # Encrypted at the top level with slots inside
        if "encrypted" in entry and "slots" in entry["encrypted"]:
            enc = entry["encrypted"]
            mname = get_key(enc, "luks2.mname")
            if not isinstance(mname, str):
                sys.stderr.write("Error: encrypted.luks2.mname missing or invalid\n")
                sys.exit(1)
            slots = enc.get("slots", {})
            for slot, slotval in slots.items():
                for part in slotval.get("partitions", []):
                    static = part.get("static")
                    if static is None:
                        continue
                    role = chk_static(static)
                    idx = next_mapper_index(mname)
                    triplets[(slot, role)] = f"mapper:{mname}:{idx}"
            continue

        # Slots at the top level; may contain unencrypted and/or nested encrypted
        if "slots" in entry:
            slots = entry["slots"]
            for slot, slotval in slots.items():
                # Nested encrypted for this slot
                if "encrypted" in slotval:
                    enc = slotval["encrypted"]
                    mname = get_key(enc, "luks2.mname")
                    if not isinstance(mname, str):
                        sys.stderr.write("Error: slots[*].encrypted.luks2.mname missing or invalid\n")
                        sys.exit(1)
                    for part in enc.get("partitions", []):
                        static = part.get("static")
                        if static is None:
                            continue
                        role = chk_static(static)
                        idx = next_mapper_index(mname)
                        triplets[(slot, role)] = f"mapper:{mname}:{idx}"

                # Unencrypted partitions for this slot
                if isinstance(slotval.get("partitions"), list):
                    for part in slotval.get("partitions", []):
                        physical_part_index += 1
                        static = part.get("static")
                        if static is None:
                            continue
                        role = chk_static(static)
                        triplets[(slot, role)] = f"::{physical_part_index}"

            continue

    # Emit triplets in canonical order if present
    def emit(slot_letter, role):
        key = (slot_letter, role)
        if key in triplets:
            print(f"{slot_letter.lower()}.{role}={triplets[key]}")

    for s in ("A", "B"):
        emit(s, "boot")
        emit(s, "system")



# Best effort general purpose JSON key retrieval
def get_key(data, key_path, default=None):
    keys = key_path.split('.')
    val = data
    for key in keys:
        if isinstance(val, dict):
            if key in val:
                val = val[key]
            else:
                return default
        elif isinstance(val, list):
            # Try to interpret key as an integer index
            try:
                idx = int(key)
                val = val[idx]
            except (ValueError, IndexError):
                # Optionally, search all items for the key
                for item in val:
                    if isinstance(item, dict) and key in item:
                        val = item[key]
                        break
                else:
                    return default
        else:
            return default
    return val



if __name__ == '__main__':
    parser = argparse.ArgumentParser(
            description='PMAP helper')

    parser.add_argument("-f", "--file",
                        help="Path to PMAP file",
                        required=True)

    parser.add_argument("-s", "--slotvars",
                        action="store_true",
                        help="Print slot.map triplets (a.boot=..., a.system=..., b.boot=..., b.system=...)")

    parser.add_argument("--get-key",
                        help="Dot-separated key path to retrieve from PMAP JSON")

    args = parser.parse_args()

    with open(args.file) as f:
        data = json.load(f)

    major, minor, patch = validate(data)

    if args.get_key:
        value = get_key(data, args.get_key)
        if value is None:
            sys.exit(1)
        else:
            print(value)
            sys.exit(0)

    major, minor, patch = validate(data)

    if args.slotvars:
        slotvars(data)
        sys.exit(0);
