# SD Card Image with MBR boot partition (for Raspberry Pi)
image <IMAGE_NAME>.<IMAGE_SUFFIX>.sparse {
   android-sparse {
      image = <IMAGE_NAME>.<IMAGE_SUFFIX>
   }
}

image boot.vfat.sparse {
   android-sparse {
      image = boot.vfat
   }
}

# Empty MD RAID1 container
image mdraid.empty.sparse {
   android-sparse {
      image = mdraid.empty
   }
}

# Main SD card image with MBR (boot only)
image <IMAGE_NAME>.<IMAGE_SUFFIX> {
   hdimage {
      align = 8M
      partition-table-type = "mbr"
      fill = true
   }

   partition boot {
      in-partition-table = true
      partition-type = 0xC
      image = boot.vfat
      bootable = true
   }
}

# Boot partition (VFAT) - contains LUKS key and bootloader
image boot.vfat {
   vfat {
      label = "BOOT"
      extraargs = "-S <SECTOR_SIZE> -i <BOOT_LABEL>"
   }
   size = <BOOT_SIZE>
   mountpoint = "/boot/firmware"
   exec-pre = "<SETUP> BOOT <BOOT_UUID> <CRYPT_UUID>"
}

# Empty MD RAID1 container (will be filled during provisioning)
# Optimized for SSD storage with 4K sectors
image mdraid.empty {
   mdraid {
      level = 1
      devices = 2
      raid-uuid = "<MD_UUID>"
      sectorsize = 4096
      # No image = empty RAID container
   }
   size = <ROOT_SIZE>
}

# Root filesystem (Btrfs) - Server-optimized for enterprise workloads
# Based on Debian mkfs.btrfs man page recommendations for production servers
image root.btrfs {
   btrfs {
      label = "CRYPTROOT"
      extraargs = "-U <BTRFS_UUID> \
                   --csum blake2 \
                   -n 32768 \
                   -s 4096 \
                   -O free-space-tree,extref"
      # inode-flags: Оптимизация производительности для критичных субтомов
      # nodatacow: Отключает COW для высокой производительности записи
      # nodatasum: Отключает checksums данных (экономит CPU, рискует integrity)
      inode-flags = "nodatacow:@swap,nodatasum:@swap"
      inode-flags = "nodatacow:@tmp"
      inode-flags = "nodatacow:@var"
      # Создаем subvolumes через genimage subvol директивы
      subvol = "@"
      subvol = "@home"
      subvol = "@var"
      subvol = "@srv"
      subvol = "@opt"
      subvol = "@tmp"
      subvol = "@swap"
   }
   size = <ROOT_SIZE>
   mountpoint = "/"
}

# Swap will be created as a subvolume on the root Btrfs filesystem
# This provides better space management and avoids COW overhead

# Note: During provisioning:
# 1. Boot partition is written to SD card (MBR)
# 2. GPT partition table is created on mdraid.empty
# 3. Partition 1 is created in GPT on the RAID (for root filesystem)
# 4. LUKS2 is applied to the partition
# 5. root.btrfs is placed in cryptroot (contains all subvolumes including @swap)
# Final structure: SD(MBR) + RAID(GPT) -> [Partition1 -> LUKS2 -> Btrfs + Subvolumes]
#
# Server Subvolumes Layout:
# @        - Root filesystem (default subvolume)
# @home    - User home directories (/home)
# @var     - Variable data (/var)
# @srv     - Server data (/srv)
# @opt     - Optional software (/opt)
# @tmp     - Temporary files (/tmp)
# @swap    - Swap subvolume (for swapfile, nocow)
#
# Btrfs Server Optimizations (per Debian mkfs.btrfs man page):
# - MD RAID1: 4K sectorsize for SSD alignment and performance
# - Default profiles: single data, DUP metadata (optimal for single device, SSD-friendly)
# - BLAKE2 checksums: Stronger integrity than default CRC32C
# - 32K nodesize: Optimized for server workloads, reduces fragmentation
# - 4K sectorsize: Explicitly set for SSD alignment and optimal performance
# - No compression: Disabled for maximum I/O performance (can be enabled per-subvolume if needed)
# - Free-space-tree: Modern space_cache=v2 for better space management
# - Extref: Support for >64K hardlinks per file (enterprise requirement)
# - Swap optimizations: inode-flags nodatacow,nodatasum для swap субтома
# - Performance optimizations: nodatacow для @tmp и @var субтомов
